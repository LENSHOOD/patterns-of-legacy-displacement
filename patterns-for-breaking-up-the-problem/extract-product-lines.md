# Extract Product Lines

> 本文是对 [Ian Cartwright](https://www.linkedin.com/in/ian-cartwright-282952/)， [Rob Horn](https://www.linkedin.com/in/rob-horn)，和 [James Lewis](https://bovon.org/) 的文章 [*Extract Product Lines*](https://martinfowler.com/articles/patterns-legacy-displacement/extract-product-lines.html) 的中文翻译。
>

*通过产品线识别并分离系统*

---

许多应用程序旨在从同一物理系统中提供多个逻辑产品的服务。通常，这是由系统重用的愿望而驱动的。例如，“嗯，消费者贷款看起来与商业贷款非常相似” 或者 “衣服是一种产品，定制窗帘也是，它们有多大不同呢？” 我们遇到的一个主要问题是，表面上这些产品看起来相似，但在细节方面却非常不同。

随着时间的推移，为多个产品提供服务的单一系统可能会变得过于通用化，代码会不断发展以处理所有可能的产品组合。例如，对于一个通用系统，它被设计为处理 n 种产品，每种产品有 n 种变化，为了检查所有可能的组合而必须进行的测试，其工作量是 n 的阶乘。这是一个很快就会变得很大的数字。这也解释了为什么作者遇到的许多此类应用程序几乎没有自动化测试覆盖，而是依赖于庞大的，通常是手工的回归测试。因为根本无法测试这么多不同的代码路径。

> **一个与 ”条件“ 有关的例子**
>
> 在零售银行领域的另一个例子中，静态分析让我们发现了一个带有 61 个嵌套 if 语句的 Java 类。这使得 Daniel Terhorst-North 得出了这样的观察：并没有一个所谓少于多少个嵌套 if 语句的数量是合理的，因为如果你有一个if语句，很明显可以添加另一个，但如果你有60个呢，你还能做什么呢？尽管这个例子确实是一种病态的情况，但它确实说明了，如果我们不小心，某个为多个产品提供服务的单一代码库 - 在当前例子里是贷款 - 会演变成什么样子。

因此，问题通常是经济成本。开发和维护每个产品的系统可能比开发和维护单一系统更经济，这很难令人接受。通过按产品拆分，我们利用了多个产品可以同时进行更改的优势，并通过避免可能在不需要的地方引入缺陷的组合爆炸来降低风险。

当然，这是一种权衡 - 我们不希望为红裤子和黑裤子分别建立单独的应用程序，但我们可能希望为 ”现成的“ 和 ”定制的“、”家庭保险“ 和 ”宠物保险“ 分别建立应用程序。

正如[《提取价值流》(Extract Value Streams)](extract-value-stream.md) 中所述的，不同的产品线通常具有非常不同的价值流，。

## 怎么做

**确定系统中的产品或产品线**。这将构成要构建/迁移的切片。在确定能力、数据、流程、用户等方面时，我们往往会采用不同的视角来寻找所有现有系统提供的能力，并将它们映射到新产品上。

**确定共享能力**。确定不同的产品线是否具有共享的业务能力。有几种方法可以解决这个问题，我们在[了解您的业务能力(暂未定义)]()中介绍了这些方法。我们的建议始终是强调使用而不是重用，因此如果有疑问，尽可能限制共享能力的数量。

**选择先行产品线**。你要先迁移哪个产品线？我们喜欢的一种方法是从风险角度考虑。在了解迁移对业务的风险后，我们通常会选择*第二个最有风险的产品线*。这可能感觉与 ”优先选择风险最低的产品“ 的直觉相反，但实际上我们希望找到一个足够重要的产品，以引起业务的关注，并导致他们优先考虑投入，但风险又不会高到出了问题可能导致业务失败。

**确定目标软件架构**。我们很少建议采用大爆炸替换，即同时为所有产品构建所有软件。相反，寻找适合第1步中确定的切片的适当架构。

**确定技术迁移策略**。正如我们在技术迁移模式部分中所讨论的那样，根据当前的约束条件，可以部署许多不同的选项。如果它是一个简单的 Web 应用程序，那么可能可以使用 [ForkByUrl(暂未定义)]()。在其他情况下，如 [ForkingOnIngress(暂未定义)]() 适用时，选择 [MessageRouter(暂未定义)]() 模式可能更好。请记住，技术迁移过程中可能需要[过渡架构](../patterns-for-delivery/transitional-architecture.md)。

## 什么时候用

当你想要从一个易于识别产品线的系统中得到如下好处时：

1. 独立工作。将系统拆分为单独的产品意味着可以围绕各个产品组建团队，从而可以在不涉及变更协调问题（如合并地域（merge hell）和长回归周期（long regression cycles））的情况下取得进展。
2. 具有不同的非功能性特征。你希望为每个产品提供不同的 SLO。例如，对于给定的延迟，具有不同的负载要求。
3. 具有不同的变更速率。有些产品线是稳定的，而其他产品则正在积极开发中。拆分系统意味着稳定产品不再需要冒变更风险。

## 保险业案例

在保险领域，不同的产品类型具有非常不同的特点。例如，车辆保险通常是高交易量但低利润率的，而房屋保险则相反。这个领域竞争非常激烈，因此快速做出变化的能力非常重要。我们曾经与一家保险公司合作，他们开发了一个三层架构来作为他们提供的不同产品线（包括车辆、人寿、房屋和宠物险）的报价引擎，如图1所示。

![img](https://martinfowler.com/articles/patterns-legacy-displacement/insurance-app-arch.png)



> **分层体系结构的问题**
>
> 多年来，最常见的思考方式是先考虑系统架构，其次是业务或产品架构。这导致企业中存在大量 n 层系统，并且许多老化的 COTS 产品。这种构建方式的系统通常需要很长的变更前置时间，以便跨n层进行所有协调。
>
> 在为多个产品提供服务的n层系统中，通常不可能为每个产品线以不同方式扩展系统。很少有多个产品具有完全相同的非功能性特征。这并不意味着分层总是不好的，实际上它对于[组织代码库是件好事](https://martinfowler.com/bliki/PresentationDomainDataLayering.html)。

## 明白你想要实现何种结果

业务的产品负责人越来越对变更的前置时间感到沮丧，这个时间变得越来越长。他们决定邀请 Thoughtworks 来审视他们的架构和开发过程，以确定问题的原因。该开发过程的价值流图标识出了多个限制因素，这些因素导致前置时间的爆炸性增加。虽然每个技术领域都与其他领域解耦，但不同的业务领域之间紧密耦合。这意味着为车辆保险产品添加新需求通常会影响到房屋保险、人寿保险等其他产品。这些变更意味着需要在令人焦头烂额的部署前进行仔细的思考和广泛的回归测试。多产品架构还对能够安全地在代码库上工作的人数设置了限制，进一步减缓了进展速度。

最后，由于汽车保险产品线的体量要求和业务的增长，底层数据存储必须经常进行扩展，这将需要停机时间来服务于系统中托管的所有其他产品。

## 决定如何将问题分解成更小的部分

因此，保险公司决定将其围绕技术能力组织的 n 层架构迁移到以产品线组织的架构。产品早已确定：车辆保险、住宅保险、人寿保险和宠物保险。一旦认识到了这些产品类型，便能识别出每个产品线所需的不同能力，例如个人问题集、报价和客户账户以及更多的技术能力，如身份验证和授权。客户账户被确定为所有产品线都将使用的关键共享能力，这是采用 EA 魔方图中描述的 “协调” 方法的一个很好的例子，更多细节请参见[至尊魔戒](./the-one-true-ring.md)。

接下来需要做的事情是确定从哪里开始。按公司收入的顺序，产品线的排名为车辆保险、住宅保险、人寿保险和宠物保险。而按客户数量排序则相反。因此，决定先实现独立的住宅保险产品线。这平衡了业务风险和重要性收益的关系。

## 成功地交付部件

![img](https://martinfowler.com/articles/patterns-legacy-displacement/insurance-event-driven.png)



> 这幅图展示了销售保险给客户所需的一些不同能力之间的互动关系。虽然涉及到很多细节，但其本质上是一个非常高层次的视图。
>
> 1. 客户填写完保险报价所需的各种问题并提交其表格（在业界称为“风险”）后，Home Insurance 程序会发布一个RequestQuote命令。
>2. 订阅 RabbitMQ 主题的 Quoting Engine 收到 RequestQuote 命令并执行其任务（在幕后向各种内部和外部合作伙伴发出多个请求等）。对于这家保险公司而言，这涉及到向其他40多家保险公司发送不同类型和协议的请求。如果有一个标准，整个过程将会更加容易！
> 3. 随着下游系统的回复被接收，Quoting Engine 会发布 QuoteReceived 事件到另一个 RabbitMQ 主题。
> 4. 由于除了 Home Insurance 系统外，还有许多其他能力服务也对已收到的报价事件感兴趣，因此也会做一些工作。这包括 Account Management 能力服务和 Enterprise Data Warehouse (EDW) 服务。幸运的是，这些能力服务也订阅了正确的主题，并且可以根据需要获取这些事件。
> 5. 然后，客户可能会决定选择其中一个报价来实际购买保险，并单击 “继续”。此时，将发布 PolicyPurchased 事件，Home Insurance 系统会自豪地表扬自己，因为它已经成功完成了工作。
> 6. 最后，任何对 PolicyPurchased 事件感兴趣的其他能力服务也会再次通过 RabbitMQ 接收它，并进行自己的操作（在 EDW 的情况下，将其存储以供报表目的，结合 Account Management，客户可以轻松检索到它）。
> 
> 使用这种方式发布业务事件的一个好处是依赖系统（例如数据仓库）可以轻松更新。在这种情况下，团队创建了一个简单的适配器，将新世界中发生的事情转换为旧版所需的星型模式。

上面的图显示了团队开始构建的事件驱动架构。与报价引擎和客户管理功能的通信是通过在 RabbitMQ 消息总线上传递的事件进行的。这些事件也传播到现有的企业数据仓库用于报表目的。

随着团队在一旁构建新系统，如何将流量从旧系统切换到新系统的工作也开始做准备。将整个产品线移动的一个缺点是必须完全实现问题集才能切换客户。由于这种限制，新系统进入了 Beta 阶段，某些客户被提供选择使用 Beta 版本的选项。选择参与的客户还有机会提供有关新外观和体验的反馈。随着新系统逐渐完善并添加最终的美化特性，进行版本切换的最终决策也以下达，接下来就需要逐步将客户重定向到新系统，这个过程持续了几个星期。首先是 1％，然后是 5％，然后是 10％ 等等。这使得团队和业务方可以逐步增强对新系统的功能和非功能方面的信心。最后，新系统服务了家庭保险 100％ 的流量。然后团队开始进行持续的产品开发。

## 进行组织变革，以使上述过程能持续发生

在第一次迁移成功后，注意力转向下一个挑战，团队将采用相同的方法移动车辆保险业务，直到迁移完成并关闭旧系统。

与此同时，整个技术组织逐渐从以项目为基础的开发方法转向以产品为中心的方法。当然，这种转变有些困难。对产品所有权是需要逐渐建立的技能。他们还采用了相同的方法来进行传统的 IT 运营，并在 CTO 和首席架构师的指导下，朝着按需基础设施和数据分析的平台产品工程化方向发展。
